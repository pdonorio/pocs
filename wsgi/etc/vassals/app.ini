[uwsgi]
# socket = 127.0.0.1:3031
# for unix sockets, see `chmod-socket` and `chown-socket`
# http://stackoverflow.com/a/21182437/2114395
http = 0.0.0.0:3031

stats = 127.0.0.1:9191
# use with uwsgitop:
# http://uwsgi-docs.readthedocs.org/en/latest/StatsServer.html

logto = /var/log/uwsgi/%n.log

uid = 1000
gid = 1000

binary-path = /usr/local/bin/uwsgi
chdir = /code
module = myflask
callable = app

# https://chriswarrick.com/blog/2016/02/10/deploying-python-web-apps-with-nginx-and-uwsgi-emperor/
# virtualenv = {{ api_rc_flask_virtualenv }}

# http://stackoverflow.com/a/15707326/2114395
pythonpath = /usr/lib/python3.5
pythonpath = /usr/local/lib/python3.5/dist-packages

processes = 2
threads = 4
# to dynamically scale workers see:
# http://uwsgi-docs.readthedocs.org/en/latest/Cheaper.html
enable-threads = true
thunder-lock = true
# http://uwsgi-docs.readthedocs.org/en/latest/OffloadSubsystem.html
offload-threads = 1 # one per CPU is a basic start

# harakiri = 30
# respawn processes after serving 5000 requests (avoid memory leaks)
max-requests    = 5000

# clear environment on exit
vacuum          = true

# checks python modules every N seconds for changes and autoreloads
# useful in development, avoid in production
# {% if py_autoreload is defined %}
# py-autoreload = 2
# {% endif %}

# limit-as = 512 # ?? for monitoring memory?

# From the uWSGI mailing list:
# 30-40 MB per worker is pretty normal.
#
# To gain memory you can move to multithreading:
#
# master = true
# processes = 2
# threads = 2
# thread-stacksize = 512
#
# should be good enough. Monitoring memory is a good thing,
# use --reload-on-rss 80 to avoid your app growing up
